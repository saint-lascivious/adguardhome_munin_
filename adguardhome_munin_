#!/bin/sh

#          _                       _ _                                 _
#  __ _ __| |__ _ _  _ __ _ _ _ __| | |_  ___ _ __  ___ _ __ _  _ _ _ (_)_ _
# / _` / _` / _` | || / _` | '_/ _` | ' \/ _ \ '  \/ -_) '  \ || | ' \| | ' \
# \__,_\__,_\__, |\_,_\__,_|_| \__,_|_||_\___/_|_|_\___|_|_|_\_,_|_||_|_|_||_|
#           |___/

# saint-lascivious (Hayden Pearce), 2025

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

#%# family=manual
#%# capabilities=suggest

set -e

adguardhome_munin_tempfiles=""

adguardhome_munin_cleanup_tempfiles() {
    rm -f "${adguardhome_munin_tempfiles}"
}

# Ensure temp files are cleaned up on exit, interrupt, or termination
trap adguardhome_munin_cleanup_tempfiles EXIT INT TERM

adguardhome_munin_term_cleanup() {
    # Reset terminal to sane mode
    stty sane
    printf '\n'
}

adguardhome_munin_abort_handler() {
    # Clean up and exit on SIGINT or SIGTERM
    adguardhome_munin_term_cleanup
    printf "%s\n" "Execution of '${script_path}' aborted (SIGINT or SIGTERM)." >&2
    exit 130
}

# Set terminal to sane mode on exit or interrupt
trap 'adguardhome_munin_abort_handler' INT TERM

# Shellcheck freaks out about traps in arbitrarily large scripts
if [ "${__FUCK_YOU_SHELLCHECK:-}" = "1" ]; then
    adguardhome_munin_cleanup_tempfiles
    adguardhome_munin_term_cleanup
    adguardhome_munin_abort_handler
fi

case "${0}" in
    /*)
        script_path="${0}"
    ;;
    *)
        script_path="$(cd "$(dirname "${0}")" && pwd)/$(basename "${0}")"
    ;;
esac

adguardhome_munin_plugin_id="$(printf "%s" "${script_path}" | sed -e 's/^.*adguardhome_munin_//')"

if [ -z "${adguardhome_munin_plugin_id}" ]; then
    # This should never happen
    adguardhome_munin_plugin_id="percent"
fi

adguardhome_munin_plugins="blocked clients domains percent processing queries status upstreams upstreams_avg"

proto="${proto:-"http"}"
host="${host:-"127.0.0.1"}"
port="${port:-"80"}"

api="${proto}://${host}:${port}"

login_endpoint="${login_endpoint:-"/control/login"}"
logout_endpoint="${logout_endpoint:-"/control/logout"}"
stats_endpoint="${stats_endpoint:-"/control/stats"}"
status_endpoint="${status_endpoint:-"/control/status"}"


top_n="${top_n:-"10"}"

if [ "${top_n}" -gt "30" ]; then
    top_n="30"
elif [ "${top_n}" -lt "1" ]; then
    top_n="1"
fi

agh_username="${username:-}"
agh_password="${password:-}"

graph="${graph:-"yes"}"
graph_args="${graph_args:-"--lower-limit 0"}"
graph_category="${graph_category:-"dns"}"
graph_draw="${graph_draw:-"LINE1"}"
graph_height="${graph_height:-"200"}"
graph_scale="${graph_scale:-"no"}"
[ "${graph_total:-total}" != "undef" ] && graph_total_line="graph_total ${graph_total:-total}"
graph_type="${graph_type:-"DERIVE"}"
graph_width="${graph_width:-"400"}"

state_dir=${MUNIN_PLUGSTATE:-"/tmp/adguardhome_munin_"}
state_file="${state_dir}/adguardhome_munin_${adguardhome_munin_plugin_id}.state"

# Ensure state dir exists
mkdir -p "${state_dir}"

adguardhome_munin_mktemp() {
    # Create a temporary file in a specified directory with a given prefix.
    # Arguments:
    #  ${1} = directory (optional, defaults to /tmp if not provided)
    #  ${2} = filename prefix (required, defaults to "adguardhome_munin_" if not provided)
    # Uses mktemp to ensure unique filenames.
    # Falls back to mktemp -t if the directory argument is not supported.
    mktemp_dir="${1:-/tmp}"
    mktemp_prefix="${2:-adguardhome_munin_}"
    tmpfile=$(mktemp "${mktemp_dir}/${mktemp_prefix}.XXXXXX" 2>/dev/null || mktemp -t "${mktemp_prefix}.XXXXXX")
    adguardhome_munin_tempfiles="${adguardhome_munin_tempfiles} ${tmpfile}"
    printf "%s" "${tmpfile}"
}

# Create a temporary cookie file for storing session cookies
cookie_file=$(adguardhome_munin_mktemp "${state_dir}" "cookie_file")

# Ensure all temp files are removed on exit
trap 'rm -f ${adguardhome_munin_tempfiles}' EXIT

adguardhome_munin_print() {
    # Print a Munin field definition for a given key and its attributes.
    # Arguments:
    #  ${1} = raw key (may contain any characters)
    #  ${2} = colour (hex RGB, optional)
    #  ${3} = critical (threshold value, optional)
    #  ${4} = draw (graph style, e.g. LINE1, AREA, etc., optional)
    #  ${5} = graph (yes/no, whether to graph this field)
    #  ${6} = info (description for this field)
    #  ${7} = label (human-readable label, will be sanitized below)
    #  ${8} = max (maximum value, optional)
    #  ${9} = min (minimum value, optional)
    # ${10} = type (GAUGE, COUNTER, etc., optional)
    # ${11} = warning (threshold value, optional)
    # ${12} = prefix (optional, used if key starts with a digit)
    # Sanitize key: remove backslash escapes, hash, replace non-alphanum with _
    key="$(printf "%s" "${1}" | sed 's/\\[0-9]\{3\}//g' | tr -d '#' | tr -c 'a-zA-Z0-9' '_')"
    # Prefix if key starts with a digit
    case "${key}" in
        [0-9]*) key="${adguardhome_munin_plugin_id}_${key}" ;;
    esac
    # Validate key format
    if ! printf %s "${key}" | grep -Eq '^[a-zA-Z_][a-zA-Z0-9_]*$'; then
        printf "%s\n" \
            "Error: Invalid or missing key passed to adguardhome_munin_print()." \
            "Key must contain at least one printable character after sanitization." >&2
        exit 1
    fi
    # Sanitize label: remove backslash escape sequences and hash characters
    label_clean="$(printf "%s" "${7}" | sed 's/\\[0-9]\{3\}//g' | tr -d '#')"
    # Truncate label if longer than 19 characters for Munin compatibility
    if [ "${#label_clean}" -gt 19 ]; then
        label_clean="$(printf "%s" "${label_clean}" | cut -c1-16)..."
    fi
    # Validate sanitized label
    if [ -z "${label_clean}" ]; then
        printf "%s\n" \
            "Error: Invalid or missing label passed to adguardhome_munin_print()." \
            "Label must contain at least one printable character after sanitization." >&2
        exit 1
    fi
    # Output colour if provided and valid (Munin expects 6-digit hex)
    if [ -n "${2}" ] && [ -n "$(printf '%s' "${2}" | tr -d '[:space:]')" ]; then
        colour_val="${2#\#}" # Remove leading hash if present
        # Expand 3-digit hex to 6-digit hex
        if printf %s "${colour_val}" | grep -Eq '^[0-9A-Fa-f]{3}$'; then
            r=$(printf %s "${colour_val}" | cut -c1)
            g=$(printf %s "${colour_val}" | cut -c2)
            b=$(printf %s "${colour_val}" | cut -c3)
            colour_val="${r}${r}${g}${g}${b}${b}"
        fi
        if printf %s "${colour_val}" | grep -Eq '^[0-9A-Fa-f]{6}$'; then
            printf "%s.colour %s\n" "${key}" "${colour_val}"
        fi
    fi
    # Output critical threshold if provided and valid
    if [ -n "${3}" ] && [ -n "$(printf '%s' "${3}" | tr -d '[:space:]')" ]; then
        if printf %s "${3}" | grep -Eq '^(-?[0-9]+(\.[0-9]*)?)?(:(-?[0-9]+(\.[0-9]*)?)?)?$|^(-?[0-9]+(\.[0-9]*)?):$'; then
            printf "%s.critical %s\n" "${key}" "${3}"
        fi
    fi
    # Output draw style if provided and valid
    if [ -n "${4}" ] && [ -n "$(printf '%s' "${4}" | tr -d '[:space:]')" ]; then
        if printf %s "${4}" | grep -Eq '^LINE[0-9]*$|^AREA$|^STACK$|^AREASTACK$|^LINESTACK[0-9]*$'; then
            printf "%s.draw %s\n" "${key}" "${4}"
        fi
    fi
    # Output graph flag if provided and valid
    if [ -n "${5}" ] && [ -n "$(printf '%s' "${5}" | tr -d '[:space:]')" ]; then
        case "${5}" in
            "yes"|"true") printf "%s.graph %s\n" "${key}" "yes" ;;
            "no"|"false") printf "%s.graph %s\n" "${key}" "no" ;;
        esac
    fi
    # Output info string if provided
    if [ -n "${6}" ] && [ -n "$(printf '%s' "${6}" | tr -d '[:space:]')" ]; then
        printf "%s.info %s\n" "${key}" "${6}"
    fi
    # Output sanitized label
    printf "%s.label %s\n" "${key}" "${label_clean}"
    # Output max value if provided and valid
    if [ -n "${8}" ] && [ -n "$(printf '%s' "${8}" | tr -d '[:space:]')" ]; then
        if printf %s "${8}" | grep -Eq '^(-?[0-9]+(\.[0-9]*)?)$'; then
            printf "%s.max %s\n" "${key}" "${8}"
        fi
    fi
    # Output min value if provided and valid
    if [ -n "${9}" ] && [ -n "$(printf '%s' "${9}" | tr -d '[:space:]')" ]; then
        if printf %s "${9}" | grep -Eq '^(-?[0-9]+(\.[0-9]*)?)$'; then
            printf "%s.min %s\n" "${key}" "${9}"
        fi
    fi
    # Output type if provided and valid (Munin expects GAUGE, COUNTER, DERIVE, ABSOLUTE)
    if [ -n "${10}" ] && [ -n "$(printf '%s' "${10}" | tr -d '[:space:]')" ]; then
        case "${10}" in
            "GAUGE"|"COUNTER"|"DERIVE"|"ABSOLUTE")
                printf "%s.type %s\n" "${key}" "${10}"
            ;;
        esac
    fi
    # Output warning threshold if provided and valid
    if [ -n "${11}" ] && [ -n "$(printf '%s' "${11}" | tr -d '[:space:]')" ]; then
        if printf %s "${11}" | grep -Eq '^(-?[0-9]+(\.[0-9]*)?)?(:(-?[0-9]+(\.[0-9]*)?)?)?$|^(-?[0-9]+(\.[0-9]*)?):$'; then
            printf "%s.warning %s\n" "${key}" "${11}"
        fi
    fi
}

adguardhome_munin_auth() {
    # Authenticate with AdGuard Home API and store session cookie.
    # Sends a POST request with username and password to the login endpoint.
    # Stores cookies in ${cookie_file} for subsequent requests.
    # Returns 0 on success, 1 on failure.
    auth_response=$(curl --connect-timeout 2 --insecure --show-error --silent \
        --location -H "Content-Type: application/json" -c "${cookie_file}" \
        -d "{\"name\":\"${agh_username}\",\"password\":\"${agh_password}\"}" \
        -w "\n%{http_code}" "${api}${login_endpoint}")
    # Extract HTTP status code from response
    http_code=$(printf "%s" "${auth_response}" | tail -n1)
    case "${http_code}" in
        "200") return 0 ;; # Login successful
        "400")
            # Invalid credentials
            printf "%s\n" \
                "Error: Invalid AdGuard Home credentials." \
                "Please check your username and password." >&2
            return 1
            ;;
        "429")
            # Too many login attempts
            printf "%s\n" \
                "Error: Too many login attempts to AdGuard Home." \
                "Please wait and try again later." >&2
            return 1
            ;;
        *)
            # Any other response code
            # This could indicate an API error or misconfiguration
            printf "%s\n" \
                "Error: Unexpected response from AdGuard Home." \
                "Unexpected response code from AdGuard Home API (login): ${http_code}" >&2
            return 1
            ;;
    esac
}

adguardhome_munin_logout() {
    # Log out from AdGuard Home API and clean up session cookie.
    # Sends a GET request to the logout endpoint using the stored cookie.
    # Removes the cookie file after logout.
    # Returns 0 on success, 1 on failure.
    logout_response=$(curl --connect-timeout 2 --insecure --show-error --silent \
        --location -H "Content-Type: application/json" -b "${cookie_file}" \
        -w "\n%{http_code}" "${api}${logout_endpoint}")
    # Extract HTTP status code from response
    http_code=$(printf "%s" "${logout_response}" | tail -n1)
    rm -f "${cookie_file}"
    case "${http_code}" in
        "200") return 0 ;; # Logout successful
        *)
            # Any other error
            printf "%s\n" \
                "Error: Unexpected response from AdGuard Home." \
                "Unexpected response code from AdGuard Home API (logout): ${http_code}" >&2
            return 1
            ;;
    esac
}

adguardhome_munin_rev_ptr() {
    ip_port="$1"
    reverse_lookup_cache="${state_dir}/adguardhome_munin_rev_ptr.state"
    # Remove brackets for IPv6 [::1]:5353
    ip_port=$(printf "%s" "${ip_port}" | sed 's/^\[\(.*\)\]$/\1/')
    # Extract IP from IP:PORT
    if printf "%s" "${ip_port}" | grep -Eq '^\[?[0-9a-fA-F:]+\]?:[0-9]+$'; then
        ip=$(printf "%s" "${ip_port}" | sed 's/\(.*\):[0-9]\+$/\1/')
    elif printf "%s" "${ip_port}" | grep -Eq '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+(:[0-9]+)?$'; then
        ip=$(printf "%s" "${ip_port}" | cut -d: -f1)
    else
        ip="${ip_port}"
    fi
    # Check cache first
    if grep -q "^${ip} " "${reverse_lookup_cache}" 2>/dev/null; then
        cached=$(grep "^${ip} " "${reverse_lookup_cache}" | head -n1 | cut -d' ' -f2-)
        if [ "${cached}" = "-" ]; then
            printf "%s\n" "${ip_port}"
        else
            printf "%s\n" "${cached}"
        fi
        return
    fi
    # Do reverse lookup
    hostname=$(getent hosts "${ip}" | awk '{print $2}' | head -n1)
    if [ -z "${hostname}" ]; then
        hostname=$(dig +time=2 +short -x "${ip}" | head -n1)
    fi
    # Cache result (negative or positive)
    if [ -n "${hostname}" ]; then
        printf "%s %s\n" "${ip}" "${hostname}" >> "${reverse_lookup_cache}"
        printf "%s\n" "${hostname}"
    else
        printf "%s -\n" "${ip}" >> "${reverse_lookup_cache}"
        printf "%s\n" "${ip_port}"
    fi
}

adguardhome_munin_config_blocked() {
    # Output Munin graph configuration for the "blocked" plugin.
    # This sets up the graph's appearance and labels.
    # Query AdGuard Home API for blocked domain stats.
    blocked_response=$(curl --connect-timeout 2 --insecure --show-error \
        --silent --location -b "${cookie_file}" "${api}${stats_endpoint}")
    # Extract the top blocked domains and their values, filter out lines with missing values.
    blocked_tmp_state=$(adguardhome_munin_mktemp "${state_dir}" "blocked_state_tmp")
    printf "%s\n" "${blocked_response}" | jq -r ".top_blocked_domains[:${top_n}][] | to_entries[] | \"\(.key) \(.value)\"" | \
        awk 'NF == 2' > "${blocked_tmp_state}"
    # Merge new key-value pairs into the persistent state file, keeping the latest value for each key.
    if [ -s "${blocked_tmp_state}" ]; then
        if [ -f "${state_file}" ]; then
            awk '
                { a[$1]=$2 }
                END { for (k in a) print k, a[k] }
            ' "${state_file}" "${blocked_tmp_state}" > "${state_file}.merged"
            mv "${state_file}.merged" "${state_file}"
        else
            mv "${blocked_tmp_state}" "${state_file}"
        fi
    fi
    rm -f "${blocked_tmp_state}"
    # Only print graph_total_line if the state file is non-empty
    if [ -s "${state_file}" ]; then
        print_total_line="${graph_total_line}"
    else
        print_total_line=""
    fi
    # Output Munin graph configuration header
    printf "%s\n" \
        "graph ${graph}" \
        "graph_args ${graph_args}" \
        "graph_category ${graph_category}" \
        "graph_height ${graph_height}" \
        "graph_info This graph shows AdGuard Home's top blocked domains" \
        "graph_scale ${graph_scale}" \
        "graph_title AdGuard Home top blocked domains" \
        "${print_total_line}" \
        "graph_vlabel blocks / second" \
        "graph_width ${graph_width}"
    # Print Munin field definitions for all keys in the state file, sorted by value (highest first)
    if [ -s "${state_file}" ]; then
        # Sort by value (column 2), numeric, descending
        sort -k2,2nr "${state_file}" | while read -r raw_key raw_value; do
            key="$(printf "%s" "${raw_key}" | sed 's/\\[0-9]\{3\}//g' | tr -d '#' | tr -c 'a-zA-Z0-9' '_')"
            if [ "${graph_type}" = "DERIVE" ]; then
                addn_info=" (${raw_value} blocks)"
            fi
            info="AdGuard Home blocked domain ${raw_key}${addn_info}"
            label="${raw_key}"
            adguardhome_munin_print \
                "${key}" \
                "" \
                "" \
                "${graph_draw}" \
                "yes" \
                "${info}" \
                "${label}" \
                "" \
                "0" \
                "${graph_type}" \
                ""
        done
    else
        # If no blocked domains, output a placeholder field
        adguardhome_munin_print \
            "none" \
            "" \
            "" \
            "${graph_draw}" \
            "yes" \
            "No blocked domains" \
            "none" \
            "" \
            "0" \
            "${graph_type}" \
            ""
    fi
}

adguardhome_munin_fetch_blocked() {
    # Fetch current values for the "blocked" plugin.
    # Queries AdGuard Home API for blocked domain stats.
    if [ -z "${blocked_response}" ]; then
        blocked_response=$(curl --connect-timeout 2 --insecure --show-error \
            --silent --location -b "${cookie_file}" "${api}${stats_endpoint}")
    fi
    blocked_tmp_state=$(adguardhome_munin_mktemp "${state_dir}" "blocked_state_tmp")
    # Extract domain and count pairs, filter out lines with missing values.
    printf "%s\n" "${blocked_response}" | jq -r ".top_blocked_domains[:${top_n}][] | to_entries[] | \"\(.key) \(.value)\"" | \
    awk 'NF == 2' > "${blocked_tmp_state}.filtered"
    # Merge new values into persistent state file, keeping the latest value for each key.
    if [ -f "${state_file}" ]; then
        awk '
            { a[$1]=$2 }
            END { for (k in a) print k, a[k] }
        ' "${state_file}" "${blocked_tmp_state}.filtered" > "${state_file}.merged"
        mv "${state_file}.merged" "${state_file}"
    else
        mv "${blocked_tmp_state}.filtered" "${state_file}"
    fi
    rm -f "${blocked_tmp_state}" "${blocked_tmp_state}.filtered"
    # Output values for Munin, fill-forward last known value, print U if missing.
    if [ ! -s "${state_file}" ]; then
        printf "none.value 0\n"
        return
    fi
    while read -r blocked_domain num_blocked; do
        key="$(printf "%s" "${blocked_domain}" | sed 's/\\[0-9]\{3\}//g' | tr -d '#' | tr -c 'a-zA-Z0-9' '_')"
        case "${key}" in
            [0-9]*) key="${adguardhome_munin_plugin_id}_${key}" ;;
        esac
        if [ -n "${num_blocked}" ]; then
            printf "%s.value %s\n" "${key}" "${num_blocked}"
        else
            printf "%s.value U\n" "${key}"
        fi
    done < "${state_file}"
}

adguardhome_munin_config_clients() {
    # Output Munin graph configuration for the "clients" plugin.
    # This sets up the graph's appearance and labels for top clients.
    # Query AdGuard Home API for client stats.
    clients_response=$(curl --connect-timeout 2 --insecure --show-error \
        --silent --location -b "${cookie_file}" "${api}${stats_endpoint}")
    # Extract the top clients and their values, filter out lines with missing values.
    clients_tmp_state=$(adguardhome_munin_mktemp "${state_dir}" "clients_state_tmp")
    printf "%s\n" "${clients_response}" | jq -r ".top_clients[:${top_n}][] | to_entries[] | \"\(.key) \(.value)\"" | \
        awk 'NF == 2' > "${clients_tmp_state}"
    # Merge new key-value pairs into the persistent state file, keeping the latest value for each key.
    if [ -s "${clients_tmp_state}" ]; then
        if [ -f "${state_file}" ]; then
            awk '{ a[$1]=$2 } END { for (k in a) print k, a[k] }' "${state_file}" "${clients_tmp_state}" > "${state_file}.merged"
            mv "${state_file}.merged" "${state_file}"
        else
            mv "${clients_tmp_state}" "${state_file}"
        fi
    fi
    rm -f "${clients_tmp_state}"
    # Only print graph_total_line if the state file is non-empty
    if [ -s "${state_file}" ]; then
        print_total_line="${graph_total_line}"
    else
        print_total_line=""
    fi
    # Output Munin graph configuration header
    printf "%s\n" \
        "graph ${graph}" \
        "graph_args ${graph_args}" \
        "graph_category ${graph_category}" \
        "graph_height ${graph_height}" \
        "graph_info This graph shows AdGuard Home's top clients" \
        "graph_scale ${graph_scale}" \
        "graph_title AdGuard Home top clients" \
        "${print_total_line}" \
        "graph_vlabel queries / second" \
        "graph_width ${graph_width}"
    # Print Munin field definitions for all keys in the state file, sorted by value (highest first)
    if [ -s "${state_file}" ]; then
        # Sort by value (column 2), numeric, descending
        sort -k2,2nr "${state_file}" | while read -r raw_key raw_value; do
            key="$(printf "%s" "${raw_key}" | sed 's/\\[0-9]\{3\}//g' | tr -d '#' | tr -c 'a-zA-Z0-9' '_')"
            resolved="$(adguardhome_munin_rev_ptr "${raw_key}")"
            port="$(printf "%s" "${raw_key}" | awk -F: '{print $2}')"
            if [ "${graph_type}" = "DERIVE" ]; then
                addn_info=" (${raw_value} queries)"
            fi
            if [ -n "${resolved}" ] && [ "${resolved}" != "${raw_key}" ]; then
                info="AdGuard Home client ${resolved} ${raw_key}${addn_info}"
                label="${resolved}:${port}"
            else
                info="AdGuard Home client ${raw_key}${addn_info}"
                label="${raw_key}"
            fi
            adguardhome_munin_print \
                "${key}" \
                "" \
                "" \
                "${graph_draw}" \
                "yes" \
                "${info}" \
                "${label}" \
                "" \
                "0" \
                "${graph_type}" \
                ""
        done
    else
        # If no clients, output a placeholder field
        adguardhome_munin_print \
            "none" \
            "" \
            "" \
            "${graph_draw}" \
            "yes" \
            "No clients" \
            "none" \
            "" \
            "0" \
            "${graph_type}" \
            ""
    fi
}

adguardhome_munin_fetch_clients() {
    # Fetch current values for the "clients" plugin.
    # Queries AdGuard Home API for client stats.
    if [ -z "${clients_response}" ]; then
        clients_response=$(curl --connect-timeout 2 --insecure --show-error \
            --silent --location -b "${cookie_file}" "${api}${stats_endpoint}")
    fi
    clients_tmp_state=$(adguardhome_munin_mktemp "${state_dir}" "clients_state_tmp")
    # Extract client and count pairs, filter out lines with missing values.
    printf "%s\n" "${clients_response}" | jq -r ".top_clients[:${top_n}][] | to_entries[] | \"\(.key) \(.value)\"" | \
    awk 'NF == 2' > "${clients_tmp_state}.filtered"
    # Merge new values into persistent state file, keeping the latest value for each key.
    if [ -f "${state_file}" ]; then
        awk '
            { a[$1]=$2 }
            END { for (k in a) print k, a[k] }
        ' "${state_file}" "${clients_tmp_state}.filtered" > "${state_file}.merged"
        mv "${state_file}.merged" "${state_file}"
    else
        mv "${clients_tmp_state}.filtered" "${state_file}"
    fi
    rm -f "${clients_tmp_state}" "${clients_tmp_state}.filtered"
    # Output values for Munin, fill-forward last known value, print U if missing.
    if [ ! -s "${state_file}" ]; then
        printf "none.value 0\n"
        return
    fi
    while read -r client num_queries; do
        key="$(printf "%s" "${client}" | sed 's/\\[0-9]\{3\}//g' | tr -d '#' | tr -c 'a-zA-Z0-9' '_')"
        case "${key}" in
            [0-9]*) key="${adguardhome_munin_plugin_id}_${key}" ;;
        esac
        if [ -n "${num_queries}" ]; then
            printf "%s.value %s\n" "${key}" "${num_queries}"
        else
            printf "%s.value U\n" "${key}"
        fi
    done < "${state_file}"
}

adguardhome_munin_config_domains() {
    # Output Munin graph configuration for the "domains" plugin.
    # This sets up the graph's appearance and labels for top domains.
    # Query AdGuard Home API for domain stats.
    domains_response=$(curl --connect-timeout 2 --insecure --show-error \
        --silent --location -b "${cookie_file}" "${api}${stats_endpoint}")
    # Extract the top domains and their values, filter out lines with missing values.
    domains_tmp_state=$(adguardhome_munin_mktemp "${state_dir}" "domains_state_tmp")
    printf "%s\n" "${domains_response}" | jq -r ".top_queried_domains[:${top_n}][] | to_entries[] | \"\(.key) \(.value)\"" | \
        awk 'NF == 2' > "${domains_tmp_state}"
    # Merge new key-value pairs into the persistent state file, keeping the latest value for each key.
    if [ -s "${domains_tmp_state}" ]; then
        if [ -f "${state_file}" ]; then
            awk '
                { a[$1]=$2 }
                END { for (k in a) print k, a[k] }
            ' "${state_file}" "${domains_tmp_state}" > "${state_file}.merged"
            mv "${state_file}.merged" "${state_file}"
        else
            mv "${domains_tmp_state}" "${state_file}"
        fi
    fi
    rm -f "${domains_tmp_state}"
    # Only print graph_total_line if the state file is non-empty
    if [ -s "${state_file}" ]; then
        print_total_line="${graph_total_line}"
    else
        print_total_line=""
    fi
    # Output Munin graph configuration header
    printf "%s\n" \
        "graph ${graph}" \
        "graph_args ${graph_args}" \
        "graph_category ${graph_category}" \
        "graph_height ${graph_height}" \
        "graph_info This graph shows AdGuard Home's top domains" \
        "graph_scale ${graph_scale}" \
        "graph_title AdGuard Home top domains" \
        "${print_total_line}" \
        "graph_vlabel queries / second" \
        "graph_width ${graph_width}"
    # Print Munin field definitions for all keys in the state file, sorted by value (highest first)
    if [ -s "${state_file}" ]; then
        # Sort by value (column 2), numeric, descending
        sort -k2,2nr "${state_file}" | while read -r raw_key raw_value; do
            key="$(printf "%s" "${raw_key}" | sed 's/\\[0-9]\{3\}//g' | tr -d '#' | tr -c 'a-zA-Z0-9' '_')"
            if [ "${graph_type}" = "DERIVE" ]; then
                addn_info=" (${raw_value} queries)"
            fi
            info="AdGuard Home domain ${raw_key}${addn_info}"
            label="${raw_key}"
            adguardhome_munin_print \
                "${key}" \
                "" \
                "" \
                "${graph_draw}" \
                "yes" \
                "${info}" \
                "${label}" \
                "" \
                "0" \
                "${graph_type}" \
                ""
        done
    else
        # If no domains, output a placeholder field
        adguardhome_munin_print \
            "none" \
            "" \
            "" \
            "${graph_draw}" \
            "yes" \
            "No domains" \
            "none" \
            "" \
            "0" \
            "${graph_type}" \
            ""
    fi
}

adguardhome_munin_fetch_domains() {
    # Fetch current values for the "domains" plugin.
    # Queries AdGuard Home API for domain stats.
    if [ -z "${domains_response}" ]; then
        domains_response=$(curl --connect-timeout 2 --insecure --show-error \
            --silent --location -b "${cookie_file}" "${api}${stats_endpoint}")
    fi
    domains_tmp_state=$(adguardhome_munin_mktemp "${state_dir}" "domains_state_tmp")
    # Extract domain and count pairs, filter out lines with missing values.
    printf "%s\n" "${domains_response}" | jq -r ".top_queried_domains[:${top_n}][] | to_entries[] | \"\(.key) \(.value)\"" | \
    awk 'NF == 2' > "${domains_tmp_state}.filtered"
    # Merge new values into persistent state file, keeping the latest value for each key.
    if [ -f "${state_file}" ]; then
        awk '
            { a[$1]=$2 }
            END { for (k in a) print k, a[k] }
        ' "${state_file}" "${domains_tmp_state}.filtered" > "${state_file}.merged"
        mv "${state_file}.merged" "${state_file}"
    else
        mv "${domains_tmp_state}.filtered" "${state_file}"
    fi
    rm -f "${domains_tmp_state}" "${domains_tmp_state}.filtered"
    # Output values for Munin, fill-forward last known value, print U if missing.
    if [ ! -s "${state_file}" ]; then
        printf "none.value 0\n"
        return
    fi
    while read -r domain num_queries; do
        key="$(printf "%s" "${domain}" | sed 's/\\[0-9]\{3\}//g' | tr -d '#' | tr -c 'a-zA-Z0-9' '_')"
        case "${key}" in
            [0-9]*) key="${adguardhome_munin_plugin_id}_${key}" ;;
        esac
        if [ -n "${num_queries}" ]; then
            printf "%s.value %s\n" "${key}" "${num_queries}"
        else
            printf "%s.value U\n" "${key}"
        fi
    done < "${state_file}"
}

adguardhome_munin_config_percent() {
    # Output Munin graph configuration for the "percent" plugin.
    # This sets up the graph's appearance for blocked query percentage.
    printf "%s\n" \
        "graph ${graph}" \
        "graph_args --upper-limit 100 --lower-limit 0" \
        "graph_category ${graph_category}" \
        "graph_height ${graph_height}" \
        "graph_info This graph shows AdGuard Home's blocked query percentage" \
        "graph_scale ${graph_scale}" \
        "graph_title AdGuard Home percent blocked" \
        "graph_vlabel percent blocked" \
        "graph_width ${graph_width}"
    # Print Munin field definition for percent blocked.
    adguardhome_munin_print \
        "percent_blocked" \
        "" \
        "90" \
        "${graph_draw}" \
        "yes" \
        "AdGuard Home percent blocked" \
        "percent blocked" \
        "100" \
        "0" \
        "GAUGE" \
        "0:85"
}

adguardhome_munin_fetch_percent() {
    # Fetch current value for the "percent" plugin.
    # Queries AdGuard Home API for DNS query and blocked stats.
    if [ -z "${percent_response}" ]; then
        percent_response=$(curl --connect-timeout 2 --insecure --show-error \
            --silent --location -b "${cookie_file}" "${api}${stats_endpoint}")
    fi
    if [ -z "${percent_response}" ]; then
        # Output unknown value if API response is empty.
        printf "percent_blocked.value U\n"
        return
    fi
    num_dns_queries=$(printf "%s" "${percent_response}" | jq -r '.num_dns_queries')
    num_blocked_filtering=$(printf "%s" "${percent_response}" | jq -r '.num_blocked_filtering')
    if [ -z "${num_dns_queries}" ] || [ "${num_dns_queries}" -eq "0" ]; then
        percent_blocked="0"
    else
        # Calculate percentage of blocked queries.
        percent_blocked=$(awk "BEGIN { printf \"%.2f\", (${num_blocked_filtering}/${num_dns_queries})*100 }")
    fi
    printf "percent_blocked.value %s\n" "${percent_blocked}"
}

adguardhome_munin_config_processing() {
    # Output Munin graph configuration for the "processing" plugin.
    # This sets up the graph's appearance for average DNS processing time.
    printf "%s\n" \
        "graph ${graph}" \
        "graph_args ${graph_args}" \
        "graph_category ${graph_category}" \
        "graph_height ${graph_height}" \
        "graph_info This graph shows AdGuard Home's average DNS processing time" \
        "graph_scale ${graph_scale}" \
        "graph_title AdGuard Home average processing time" \
        "graph_vlabel seconds" \
        "graph_width ${graph_width}"
    # Print Munin field definition for average processing time.
    adguardhome_munin_print \
        "avg_processing_time" \
        "" \
        "" \
        "${graph_draw}" \
        "yes" \
        "Average processing time for AdGuard Home DNS queries" \
        "avg processing time" \
        "" \
        "0" \
        "GAUGE" \
        ""
}

adguardhome_munin_fetch_processing() {
    # Fetch current value for the "processing" plugin.
    # Queries AdGuard Home API for average DNS processing time.
    if [ -z "${processing_response}" ]; then
        processing_response=$(curl --connect-timeout 2 --insecure --show-error \
            --silent --location -b "${cookie_file}" "${api}${stats_endpoint}")
    fi
    if [ -z "${processing_response}" ]; then
        # Output unknown value if API response is empty.
        printf "avg_processing_time.value U\n"
        return
    fi
    avg_processing_time=$(printf "%s" "${processing_response}" \
        | jq -r '.avg_processing_time' | awk '{ printf "%.2f", $1 }')
    if [ -z "${avg_processing_time}" ]; then
        printf "avg_processing_time.value U\n"
        return
    fi
    printf "avg_processing_time.value %s\n" "${avg_processing_time}"
}

adguardhome_munin_config_queries() {
    # Output Munin graph configuration for the "queries" plugin.
    # This sets up the graph's appearance and labels for DNS query statistics.
    queries_response=$(curl --connect-timeout 2 --insecure --show-error \
        --silent --location -b "${cookie_file}" "${api}${stats_endpoint}")
    # Extract each statistic from the API response
    num_dns_queries=$(printf "%s" "${queries_response}" | jq -r '.num_dns_queries')
    num_blocked_filtering=$(printf "%s" "${queries_response}" | jq -r '.num_blocked_filtering')
    num_replaced_safebrowsing=$(printf "%s" "${queries_response}" | jq -r '.num_replaced_safebrowsing')
    num_replaced_parental=$(printf "%s" "${queries_response}" | jq -r '.num_replaced_parental')
    num_replaced_safesearch=$(printf "%s" "${queries_response}" | jq -r '.num_replaced_safesearch')
    # Default to 0 if any statistic is missing
    num_dns_queries="${num_dns_queries:-0}"
    num_blocked_filtering="${num_blocked_filtering:-0}"
    num_replaced_safebrowsing="${num_replaced_safebrowsing:-0}"
    num_replaced_parental="${num_replaced_parental:-0}"
    num_replaced_safesearch="${num_replaced_safesearch:-0}"
    printf "%s\n" \
        "graph ${graph}" \
        "graph_args ${graph_args}" \
        "graph_category ${graph_category}" \
        "graph_height ${graph_height}" \
        "graph_info This graph shows AdGuard Home's DNS query statistics" \
        "graph_scale ${graph_scale}" \
        "graph_title AdGuard Home queries" \
        "graph_vlabel queries / second" \
        "graph_width ${graph_width}"
    adguardhome_munin_print \
        "num_dns_queries" \
        "" \
        "" \
        "${graph_draw}" \
        "yes" \
        "AdGuard Home DNS queries (${num_dns_queries} queries)" \
        "queries" \
        "" \
        "0" \
        "${graph_type}" \
        ""
    adguardhome_munin_print \
        "num_blocked_filtering" \
        "" \
        "" \
        "${graph_draw}" \
        "yes" \
        "AdGuard Home blocked filtering (${num_blocked_filtering} blocks)" \
        "filtering" \
        "" \
        "0" \
        "${graph_type}" \
        ""
    adguardhome_munin_print \
        "num_replaced_safebrowsing" \
        "" \
        "" \
        "${graph_draw}" \
        "yes" \
        "AdGuard Home replaced safebrowsing (${num_replaced_safebrowsing} replacements)" \
        "safebrowsing" \
        "" \
        "0" \
        "${graph_type}" \
        ""
    adguardhome_munin_print \
        "num_replaced_parental" \
        "" \
        "" \
        "${graph_draw}" \
        "yes" \
        "AdGuard Home replaced parental (${num_replaced_parental} replacements)" \
        "parental" \
        "" \
        "0" \
        "${graph_type}" \
        ""
    adguardhome_munin_print \
        "num_replaced_safesearch" \
        "" \
        "" \
        "${graph_draw}" \
        "yes" \
        "AdGuard Home replaced safesearch (${num_replaced_safesearch} replacements)" \
        "safesearch" \
        "" \
        "0" \
        "${graph_type}" \
        ""
}

adguardhome_munin_fetch_queries() {
    # Fetch current values for the "queries" plugin.
    # Queries AdGuard Home API for DNS query statistics.
    if [ -z "${queries_response}" ]; then
        queries_response=$(curl --connect-timeout 2 --insecure --show-error \
            --silent --location -b "${cookie_file}" "${api}${stats_endpoint}")
    fi
    if [ -z "${queries_response}" ]; then
        # Output unknown values if API response is empty.
        printf "num_dns_queries.value U\n"
        printf "num_blocked_filtering.value U\n"
        printf "num_replaced_safebrowsing.value U\n"
        printf "num_replaced_parental.value U\n"
        printf "num_replaced_safesearch.value U\n"
        return
    fi
    # Extract each statistic from the API response.
    num_dns_queries=$(printf "%s" "${queries_response}" | jq -r '.num_dns_queries')
    num_blocked_filtering=$(printf "%s" "${queries_response}" | jq -r '.num_blocked_filtering')
    num_replaced_safebrowsing=$(printf "%s" "${queries_response}" | jq -r '.num_replaced_safebrowsing')
    num_replaced_parental=$(printf "%s" "${queries_response}" | jq -r '.num_replaced_parental')
    num_replaced_safesearch=$(printf "%s" "${queries_response}" | jq -r '.num_replaced_safesearch')
    # Output values for Munin (default to 0 if missing).
    printf "num_dns_queries.value %s\n" "${num_dns_queries:-"0"}"
    printf "num_blocked_filtering.value %s\n" "${num_blocked_filtering:-"0"}"
    printf "num_replaced_safebrowsing.value %s\n" "${num_replaced_safebrowsing:-"0"}"
    printf "num_replaced_parental.value %s\n" "${num_replaced_parental:-"0"}"
    printf "num_replaced_safesearch.value %s\n" "${num_replaced_safesearch:-"0"}"
}

adguardhome_munin_config_status() {
    # Output Munin graph configuration for the "status" plugin.
    # This sets up the graph's appearance for protection status.
    printf "%s\n" \
        "graph ${graph}" \
        "graph_args --lower-limit -1 --upper-limit 1" \
        "graph_category ${graph_category}" \
        "graph_height ${graph_height}" \
        "graph_info This graph shows AdGuard Home's protection status" \
        "graph_scale ${graph_scale}" \
        "graph_title AdGuard Home status" \
        "graph_vlabel unknown / disabled / enabled" \
        "graph_width ${graph_width}"
    # Print Munin field definition for protection status.
    adguardhome_munin_print \
        "protection_status" \
        "" \
        "0:1" \
        "${graph_draw}" \
        "yes" \
        "AdGuard Home protection status" \
        "status" \
        "" \
        "-1" \
        "1" \
        "GAUGE" \
        "1:1"
}

adguardhome_munin_fetch_status() {
    # Fetch current value for the "status" plugin.
    # Queries AdGuard Home API for protection status.
    if [ -z "${status_response}" ]; then
        status_response=$(curl --connect-timeout 2 --insecure --show-error \
            --silent --location -b "${cookie_file}" "${api}${status_endpoint}")
    fi
    protection_enabled=$(printf "%s" "${status_response}" | jq -r '.protection_enabled')
    case "${protection_enabled}" in
        "true"|"yes") status_value="1" ;;
        "false"|"no") status_value="0" ;;
        *) status_value="-1" ;;
    esac
    # Output value for Munin (1 = enabled, 0 = disabled, -1 = unknown).
    printf "protection_status.value %s\n" "${status_value}"
}

adguardhome_munin_config_upstreams() {
    # Output Munin graph configuration for the "upstreams" plugin.
    # This sets up the graph's appearance and labels for top upstreams by query count.
    # Query AdGuard Home API for upstream stats.
    upstreams_response=$(curl --connect-timeout 2 --insecure --show-error \
        --silent --location -b "${cookie_file}" "${api}${stats_endpoint}")
    # Extract the top upstreams and their values, filter out lines with missing values.
    upstreams_tmp_state=$(adguardhome_munin_mktemp "${state_dir}" "upstreams_state_tmp")
    printf "%s\n" "${upstreams_response}" | jq -r ".top_upstreams_responses[:${top_n}][] | to_entries[] | \"\(.key) \(.value)\"" | \
        awk 'NF == 2' > "${upstreams_tmp_state}"
    # Merge new key-value pairs into the persistent state file, keeping the latest value for each key.
    if [ -s "${upstreams_tmp_state}" ]; then
        if [ -f "${state_file}" ]; then
            awk '{ a[$1]=$2 } END { for (k in a) print k, a[k] }' "${state_file}" "${upstreams_tmp_state}" > "${state_file}.merged"
            mv "${state_file}.merged" "${state_file}"
        else
            mv "${upstreams_tmp_state}" "${state_file}"
        fi
    fi
    rm -f "${upstreams_tmp_state}"
    # Only print graph_total_line if the state file is non-empty
    if [ -s "${state_file}" ]; then
        print_total_line="${graph_total_line}"
    else
        print_total_line=""
    fi
    # Output Munin graph configuration header
    printf "%s\n" \
        "graph ${graph}" \
        "graph_args ${graph_args}" \
        "graph_category ${graph_category}" \
        "graph_height ${graph_height}" \
        "graph_info This graph shows AdGuard Home's top upstreams" \
        "graph_scale ${graph_scale}" \
        "graph_title AdGuard Home top upstreams" \
        "${print_total_line}" \
        "graph_vlabel queries / second" \
        "graph_width ${graph_width}"
    # Print Munin field definitions for all keys in the state file, sorted by value (highest first)
    if [ -s "${state_file}" ]; then
        # Sort by value (column 2), numeric, descending
        sort -k2,2nr "${state_file}" | while read -r raw_key raw_value; do
            key="$(printf "%s" "${raw_key}" | sed 's/\\[0-9]\{3\}//g' | tr -d '#' | tr -c 'a-zA-Z0-9' '_')"
            resolved="$(adguardhome_munin_rev_ptr "${raw_key}")"
            port="$(printf "%s" "${raw_key}" | awk -F: '{print $2}')"
            if [ "${graph_type}" = "DERIVE" ]; then
                addn_info=" (${raw_value} responses)"
            fi
            if [ -n "${resolved}" ] && [ "${resolved}" != "${raw_key}" ]; then
                info="AdGuard Home upstream ${resolved} ${raw_key}${addn_info}"
                label="${resolved}:${port}"
            else
                info="AdGuard Home upstream ${raw_key}${addn_info}"
                label="${raw_key}"
            fi
            adguardhome_munin_print \
                "${key}" \
                "" \
                "" \
                "${graph_draw}" \
                "yes" \
                "${info}" \
                "${label}" \
                "" \
                "0" \
                "${graph_type}" \
                ""
        done
    else
        # If no upstreams, output a placeholder field
        adguardhome_munin_print \
            "none" \
            "" \
            "" \
            "${graph_draw}" \
            "yes" \
            "No upstreams" \
            "none" \
            "" \
            "0" \
            "${graph_type}" \
            ""
    fi
}

adguardhome_munin_fetch_upstreams() {
    # Fetch current values for the "upstreams" plugin.
    # Queries AdGuard Home API for upstream stats.
    if [ -z "${upstreams_response}" ]; then
        upstreams_response=$(curl --connect-timeout 2 --insecure --show-error \
            --silent --location -b "${cookie_file}" "${api}${stats_endpoint}")
    fi
    upstreams_tmp_state=$(adguardhome_munin_mktemp "${state_dir}" "upstreams_state_tmp")
    # Extract upstreams and their response counts, filter out lines with missing values.
    printf "%s\n" "${upstreams_response}" | jq -r ".top_upstreams_responses[:${top_n}][] | to_entries[] | \"\(.key) \(.value)\"" | \
    awk 'NF == 2' > "${upstreams_tmp_state}.filtered"
    # Merge new values into persistent state file, keeping the latest value for each key.
    if [ -f "${state_file}" ]; then
        awk '{ a[$1]=$2 } END { for (k in a) print k, a[k] }' "${state_file}" "${upstreams_tmp_state}.filtered" > "${state_file}.merged"
        mv "${state_file}.merged" "${state_file}"
    else
        mv "${upstreams_tmp_state}.filtered" "${state_file}"
    fi
    rm -f "${upstreams_tmp_state}" "${upstreams_tmp_state}.filtered"
    # Output values for Munin, fill-forward last known value, print U if missing.
    if [ ! -s "${state_file}" ]; then
        printf "none.value 0\n"
        return
    fi
    while read -r upstream num_responses; do
        key="$(printf "%s" "${upstream}" | sed 's/\\[0-9]\{3\}//g' | tr -d '#' | tr -c 'a-zA-Z0-9' '_')"
        case "${key}" in
            [0-9]*) key="${adguardhome_munin_plugin_id}_${key}" ;;
        esac
        if [ -n "${num_responses}" ]; then
            printf "%s.value %s\n" "${key}" "${num_responses}"
        else
            printf "%s.value U\n" "${key}"
        fi
    done < "${state_file}"
}

adguardhome_munin_config_upstreams_avg() {
    # Output Munin graph configuration for the "upstreams_avg" plugin.
    # This sets up the graph's appearance and labels for average upstream response time.
    # Query AdGuard Home API for average upstream response times.
    upstreams_avg_response=$(curl --connect-timeout 2 --insecure --show-error \
        --silent --location -b "${cookie_file}" "${api}${stats_endpoint}")
    # Extract the top upstreams and their values, filter out lines with missing values.
    upstreams_avg_tmp_state=$(adguardhome_munin_mktemp "${state_dir}" "upstreams_avg_state_tmp")
    printf "%s\n" "${upstreams_avg_response}" | jq -r ".top_upstreams_avg_time[:${top_n}][] | to_entries[] | \"\(.key) \(.value)\"" | \
        awk 'NF == 2' > "${upstreams_avg_tmp_state}"
    # Merge new key-value pairs into the persistent state file, keeping the latest value for each key.
    if [ -s "${upstreams_avg_tmp_state}" ]; then
        if [ -f "${state_file}" ]; then
            awk '{ a[$1]=$2 } END { for (k in a) print k, a[k] }' "${state_file}" "${upstreams_avg_tmp_state}" > "${state_file}.merged"
            mv "${state_file}.merged" "${state_file}"
        else
            mv "${upstreams_avg_tmp_state}" "${state_file}"
        fi
    fi
    rm -f "${upstreams_avg_tmp_state}"
    # Output Munin graph configuration header
    printf "%s\n" \
        "graph ${graph}" \
        "graph_args ${graph_args}" \
        "graph_category ${graph_category}" \
        "graph_height ${graph_height}" \
        "graph_info This graph shows AdGuard Home's top upstreams average response time" \
        "graph_scale ${graph_scale}" \
        "graph_title AdGuard Home top upstreams average response time" \
        "graph_vlabel seconds" \
        "graph_width ${graph_width}"
    # Print Munin field definitions for all keys in the state file, sorted by value (highest first)
    if [ -s "${state_file}" ]; then
        # Sort by value (column 2), numeric, descending
        sort -k2,2nr "${state_file}" | while read -r raw_key raw_value; do
            key="$(printf "%s" "${raw_key}" | sed 's/\\[0-9]\{3\}//g' | tr -d '#' | tr -c 'a-zA-Z0-9' '_')"
            resolved="$(adguardhome_munin_rev_ptr "${raw_key}")"
            port="$(printf "%s" "${raw_key}" | awk -F: '{print $2}')"
            if [ "${graph_type}" = "DERIVE" ]; then
                addn_info=" (${raw_value} seconds)"
            fi
            if [ -n "${resolved}" ] && [ "${resolved}" != "${raw_key}" ]; then
                info="Average response time for AdGuard Home upstream ${resolved} ${raw_key}${addn_info}"
                label="${resolved}:${port}"
            else
                info="Average response time for AdGuard Home upstream ${raw_key}${addn_info}"
                label="${raw_key}"
            fi
            adguardhome_munin_print \
                "${key}" \
                "" \
                "" \
                "${graph_draw}" \
                "yes" \
                "${info}" \
                "${label}" \
                "" \
                "0" \
                "GAUGE" \
                ""
        done
    else
        # If no upstreams, output a placeholder field
        adguardhome_munin_print \
            "none" \
            "" \
            "" \
            "${graph_draw}" \
            "yes" \
            "No upstreams" \
            "none" \
            "" \
            "0" \
            "GAUGE" \
            ""
    fi
}

adguardhome_munin_fetch_upstreams_avg() {
    # Fetch current values for the "upstreams_avg" plugin.
    # Queries AdGuard Home API for average upstream response times.
    if [ -z "${upstreams_avg_response}" ]; then
        upstreams_avg_response=$(curl --connect-timeout 2 --insecure --show-error \
            --silent --location -b "${cookie_file}" "${api}${stats_endpoint}")
    fi
    upstreams_avg_tmp_state=$(adguardhome_munin_mktemp "${state_dir}" "upstreams_avg_state_tmp")
    # Write directly to the filtered file, even if empty
    printf "%s\n" "${upstreams_response}" | jq -r ".top_upstreams_avg_time[:${top_n}][] | to_entries[] | \"\(.key) \(.value)\"" | \
    awk 'NF == 2 {
        # Format to 2 decimal places
        printf "%s %.2f\n", $1, $2 + 0
    }' > "${upstreams_avg_tmp_state}.filtered"
    # Merge new values into persistent state file, keeping the latest value for each key.
    if [ -f "${state_file}" ]; then
        awk '{ a[$1]=$2 } END { for (k in a) print k, a[k] }' "${state_file}" "${upstreams_avg_tmp_state}.filtered" > "${state_file}.merged"
        mv "${state_file}.merged" "${state_file}"
    else
        mv "${upstreams_avg_tmp_state}.filtered" "${state_file}"
    fi
    rm -f "${upstreams_avg_tmp_state}" "${upstreams_avg_tmp_state}.filtered"
    # Output values for Munin, fill-forward last known value, print U if missing.
    if [ ! -s "${state_file}" ]; then
        printf "none.value 0\n"
        return
    fi
    while read -r upstream avg_time; do
        key="$(printf "%s" "${upstream}" | sed 's/\\[0-9]\{3\}//g' | tr -d '#' | tr -c 'a-zA-Z0-9' '_')"
        case "${key}" in
            [0-9]*) key="${adguardhome_munin_plugin_id}_${key}" ;;
        esac
        if [ -n "${avg_time}" ]; then
            printf "%s.value %s\n" "${key}" "${avg_time}"
        else
            printf "%s.value U\n" "${key}"
        fi
    done < "${state_file}"
}

adguardhome_munin_fetch() {
    # Dispatch fetch operation to the appropriate plugin-specific fetch function.
    # Uses the plugin ID to select which data to retrieve.
    case "${adguardhome_munin_plugin_id}" in
        "blocked") adguardhome_munin_fetch_blocked ;;
        "clients") adguardhome_munin_fetch_clients ;;
        "domains") adguardhome_munin_fetch_domains ;;
        "percent") adguardhome_munin_fetch_percent ;;
        "processing") adguardhome_munin_fetch_processing ;;
        "queries") adguardhome_munin_fetch_queries ;;
        "status") adguardhome_munin_fetch_status ;;
        "upstreams") adguardhome_munin_fetch_upstreams ;;
        "upstreams_avg") adguardhome_munin_fetch_upstreams_avg ;;
        *)
            # Unknown plugin ID
            printf "%s\n" \
                "Error: Unknown fetch operation." \
                "Cannot fetch for unrecognised plugin '${adguardhome_munin_plugin_id}'." >&2
            exit 1
            ;;
    esac
}

adguardhome_munin_config() {
    # Dispatch config operation to the appropriate plugin-specific config function.
    # Uses the plugin ID to select which config to output.
    case "${adguardhome_munin_plugin_id}" in
        "blocked") adguardhome_munin_config_blocked ;;
        "clients") adguardhome_munin_config_clients ;;
        "domains") adguardhome_munin_config_domains ;;
        "percent") adguardhome_munin_config_percent ;;
        "processing") adguardhome_munin_config_processing ;;
        "queries") adguardhome_munin_config_queries ;;
        "status") adguardhome_munin_config_status ;;
        "upstreams") adguardhome_munin_config_upstreams ;;
        "upstreams_avg") adguardhome_munin_config_upstreams_avg ;;
        *)
            # Unknown plugin ID
            printf "%s\n" \
                "Error: Unknown config operation." \
                "Cannot config for unrecognised plugin '${adguardhome_munin_plugin_id}'." >&2
            exit 1
            ;;
    esac
    # If Munin declares the dirtyconfig capbility, we can send data on the config call.
    if [ "${MUNIN_CAP_DIRTYCONFIG}" = "1" ]; then
        adguardhome_munin_fetch
    fi
}

adguardhome_munin_check_dependencies() {
    # Check for required external commands.
    # Returns 1 if any dependency is missing, 0 otherwise.
    plugin_dependencies="awk curl grep jq mktemp sed"
    for plugin_dependency in ${plugin_dependencies}; do
        if ! command -v "${plugin_dependency}" >/dev/null 2>&1; then
            return 1
        fi
    done
}

adguardhome_munin_suggest() {
    # Output a list of supported plugin IDs for Munin's suggest mode.
    for adguardhome_munin_plugin in ${adguardhome_munin_plugins}; do
        printf "%s\n" "${adguardhome_munin_plugin}"
    done
}

adguardhome_munin_autoconf() {
    # Munin autoconf: check if the plugin might be useful on this system.
    # Returns "yes" if all requirements are met, "no" otherwise.
    if [ -z "${agh_username}" ] || [ -z "${agh_password}" ]; then
        # Missing credentials
        printf "no (missing credentials)\n"
        return
    fi
    if ! adguardhome_munin_check_dependencies >/dev/null 2>&1; then
        # Missing at least one required dependency
        printf "no (missing dependencies)\n"
        return
    fi
    if ! command -v AdGuardHome >/dev/null 2>&1 || [ ! -x "/opt/AdGuardHome/AdGuardHome" ]; then
        # AdGuard Home binary not found or not executable
        # Probably not an AdGuard Home host
        printf "no (no AdGuard Home binary)\n"
        return
    fi
    if [ -z "${adguardhome_munin_plugin_id}" ]; then
        # This should never happen
        printf "no (no plugin ID)\n"
        return
    fi
    if ! adguardhome_munin_auth >/dev/null 2>&1; then
        # Authentication failed
        printf "no (authentication failed)\n"
        return
    fi
    # All checks passed, plugin can run
    # Log out from AdGuard Home API
    adguardhome_munin_logout >/dev/null 2>&1 || true  # Ignore logout errors
    # Return "yes" to indicate plugin can run
    printf "yes\n"
}

adguardhome_munin_flush_state() {
    # Flush state files for all plugins that use them.
    # Prints the names of removed state files, or a message if none were found.
    flushed="0"
    # Only attempt to remove state files we know about
    for state in rev_ptr blocked clients domains upstreams upstreams_avg; do
        state_file="${state_dir}/adguardhome_munin_${state}.state"
        if [ -f "${state_file}" ]; then
            # Remove the state file and print its name
            rm -f "${state_file}" 2>/dev/null && printf "%s\n" "${state_file}"
            flushed=$((flushed + 1))
        fi
    done
    if [ "$flushed" -eq 0 ]; then
        printf "No state files to flush.\n"
    else
        printf "\nFlushed %d state file%s.\n" "$flushed" "$( [ "$flushed" -eq 1 ] && printf "" || printf "s" )"
    fi
    exit 0
}

# Authenticate with AdGuard Home API before running any plugin operation.
adguardhome_munin_auth || {
    printf "%s\n" \
        "Error: AdGuard Home authentication failed." \
        "Check your AdGuard Home credentials, ensure the API is accessible." >&2
    exit 1
}

# Main entry point: dispatch based on first argument.
case "${1}" in
    ""|"fetch") adguardhome_munin_fetch ;;
    "config") adguardhome_munin_config ;;
    "suggest") adguardhome_munin_suggest ;;
    "autoconf") adguardhome_munin_autoconf ;;
    "flush") adguardhome_munin_flush_state ;;
    *)
        # Unknown argument: print usage
        printf "Usage: %s [config|fetch]\n" "${script_path}" >&2
esac

# Log out from AdGuard Home API and clean up session cookie.
adguardhome_munin_logout || {
    printf "%s\n" \
        "Error: AdGuard Home logout failed." \
        "Check your AdGuard Home credentials, ensure the API is accessible." >&2
    exit 1
}

# Remove orphaned cookie files older than 60 minutes.
find "${state_dir}" -maxdepth 1 -name 'cookie_file.*' -mmin +60 -delete

#    /\_/\  
#   ( O.O ) 
#    > ^ < ((
#   /     \ ))
#   \\ | / \/
#   ((_|_) _)

exit 0
